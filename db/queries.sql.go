// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const answerQuestion = `-- name: AnswerQuestion :execresult
UPDATE unanswered_questions
SET answer = ?, answered_by = ?, status = 'answered', answered_at = datetime('now'), add_to_knowledge = ?
WHERE id = ? AND status = 'pending'
`

type AnswerQuestionParams struct {
	Answer         sql.NullString `json:"answer"`
	AnsweredBy     sql.NullInt64  `json:"answered_by"`
	AddToKnowledge sql.NullInt64  `json:"add_to_knowledge"`
	ID             int64          `json:"id"`
}

func (q *Queries) AnswerQuestion(ctx context.Context, arg AnswerQuestionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, answerQuestion,
		arg.Answer,
		arg.AnsweredBy,
		arg.AddToKnowledge,
		arg.ID,
	)
}

const approveSubmission = `-- name: ApproveSubmission :execresult
UPDATE knowledge_submissions
SET status = 'approved', reviewed_at = datetime('now'), reviewed_by = ?, admin_notes = ?
WHERE id = ? AND status = 'pending'
`

type ApproveSubmissionParams struct {
	ReviewedBy sql.NullInt64  `json:"reviewed_by"`
	AdminNotes sql.NullString `json:"admin_notes"`
	ID         int64          `json:"id"`
}

func (q *Queries) ApproveSubmission(ctx context.Context, arg ApproveSubmissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, approveSubmission, arg.ReviewedBy, arg.AdminNotes, arg.ID)
}

const approveUser = `-- name: ApproveUser :execresult
UPDATE users SET approved = 1, updated_at = datetime('now')
WHERE id = ? AND approved = 0
`

func (q *Queries) ApproveUser(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, approveUser, id)
}

const countActiveFilters = `-- name: CountActiveFilters :one
SELECT COUNT(*) as count FROM security_filters WHERE is_active = 1
`

func (q *Queries) CountActiveFilters(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveFilters)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveKnowledge = `-- name: CountActiveKnowledge :one
SELECT COUNT(*) as count FROM knowledge_base WHERE is_active = 1
`

func (q *Queries) CountActiveKnowledge(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveKnowledge)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActiveSessions = `-- name: CountActiveSessions :one
SELECT COUNT(*) as count FROM sessions WHERE expires_at > datetime('now')
`

func (q *Queries) CountActiveSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConversationMessages = `-- name: CountConversationMessages :one
SELECT COUNT(*) as count FROM ai_messages WHERE conversation_id = ?
`

func (q *Queries) CountConversationMessages(ctx context.Context, conversationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConversationMessages, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGroupMessages = `-- name: CountGroupMessages :one
SELECT COUNT(*) as count FROM group_messages
`

func (q *Queries) CountGroupMessages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGroupMessages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingQuestions = `-- name: CountPendingQuestions :one
SELECT COUNT(*) as count FROM unanswered_questions WHERE status = 'pending'
`

func (q *Queries) CountPendingQuestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingQuestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingSubmissions = `-- name: CountPendingSubmissions :one
SELECT COUNT(*) as count FROM knowledge_submissions WHERE status = 'pending'
`

func (q *Queries) CountPendingSubmissions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingSubmissions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSecurityLogsByUser = `-- name: CountSecurityLogsByUser :one
SELECT COUNT(*) as count FROM security_logs WHERE user_id = ?
`

func (q *Queries) CountSecurityLogsByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSecurityLogsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSecurityLogsToday = `-- name: CountSecurityLogsToday :one
SELECT COUNT(*) as count FROM security_logs
WHERE date(created_at) = date('now')
`

func (q *Queries) CountSecurityLogsToday(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSecurityLogsToday)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT COUNT(*) as count FROM notifications
WHERE user_id = ? AND read = 0
`

func (q *Queries) CountUnreadNotifications(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnreadNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserConversations = `-- name: CountUserConversations :one
SELECT COUNT(*) as count FROM ai_conversations WHERE user_id = ?
`

func (q *Queries) CountUserConversations(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserConversations, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAIConversation = `-- name: CreateAIConversation :one

INSERT INTO ai_conversations (user_id, title)
VALUES (?, ?)
RETURNING id, user_id, title, created_at, updated_at
`

type CreateAIConversationParams struct {
	UserID int64          `json:"user_id"`
	Title  sql.NullString `json:"title"`
}

// ============ AI CONVERSATIONS ============
func (q *Queries) CreateAIConversation(ctx context.Context, arg CreateAIConversationParams) (AiConversation, error) {
	row := q.db.QueryRowContext(ctx, createAIConversation, arg.UserID, arg.Title)
	var i AiConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAIMessage = `-- name: CreateAIMessage :one

INSERT INTO ai_messages (conversation_id, role, content, filtered, filter_reason)
VALUES (?, ?, ?, ?, ?)
RETURNING id, conversation_id, role, content, filtered, filter_reason, created_at
`

type CreateAIMessageParams struct {
	ConversationID int64          `json:"conversation_id"`
	Role           string         `json:"role"`
	Content        string         `json:"content"`
	Filtered       sql.NullInt64  `json:"filtered"`
	FilterReason   sql.NullString `json:"filter_reason"`
}

// ============ AI MESSAGES ============
func (q *Queries) CreateAIMessage(ctx context.Context, arg CreateAIMessageParams) (AiMessage, error) {
	row := q.db.QueryRowContext(ctx, createAIMessage,
		arg.ConversationID,
		arg.Role,
		arg.Content,
		arg.Filtered,
		arg.FilterReason,
	)
	var i AiMessage
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.Role,
		&i.Content,
		&i.Filtered,
		&i.FilterReason,
		&i.CreatedAt,
	)
	return i, err
}

const createFilterCategory = `-- name: CreateFilterCategory :one
INSERT INTO filter_categories (name, description)
VALUES (?, ?)
RETURNING id, name, description, is_active, created_at
`

type CreateFilterCategoryParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateFilterCategory(ctx context.Context, arg CreateFilterCategoryParams) (FilterCategory, error) {
	row := q.db.QueryRowContext(ctx, createFilterCategory, arg.Name, arg.Description)
	var i FilterCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const createGroupMessage = `-- name: CreateGroupMessage :one

INSERT INTO group_messages (user_id, content)
VALUES (?, ?)
RETURNING id, user_id, content, created_at
`

type CreateGroupMessageParams struct {
	UserID  int64  `json:"user_id"`
	Content string `json:"content"`
}

// ============ GROUP CHAT ============
func (q *Queries) CreateGroupMessage(ctx context.Context, arg CreateGroupMessageParams) (GroupMessage, error) {
	row := q.db.QueryRowContext(ctx, createGroupMessage, arg.UserID, arg.Content)
	var i GroupMessage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createKnowledge = `-- name: CreateKnowledge :one

INSERT INTO knowledge_base (title, content, category, submitted_by, approved_by, is_active, approved_at)
VALUES (?, ?, ?, ?, ?, 1, datetime('now'))
RETURNING id, title, content, category, submitted_by, approved_by, is_active, created_at, approved_at
`

type CreateKnowledgeParams struct {
	Title       string         `json:"title"`
	Content     string         `json:"content"`
	Category    sql.NullString `json:"category"`
	SubmittedBy int64          `json:"submitted_by"`
	ApprovedBy  sql.NullInt64  `json:"approved_by"`
}

// ============ KNOWLEDGE BASE ============
func (q *Queries) CreateKnowledge(ctx context.Context, arg CreateKnowledgeParams) (KnowledgeBase, error) {
	row := q.db.QueryRowContext(ctx, createKnowledge,
		arg.Title,
		arg.Content,
		arg.Category,
		arg.SubmittedBy,
		arg.ApprovedBy,
	)
	var i KnowledgeBase
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Category,
		&i.SubmittedBy,
		&i.ApprovedBy,
		&i.IsActive,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const createKnowledgeSubmission = `-- name: CreateKnowledgeSubmission :one

INSERT INTO knowledge_submissions (title, content, category, submitted_by)
VALUES (?, ?, ?, ?)
RETURNING id, title, content, category, submitted_by, status, admin_notes, created_at, reviewed_at, reviewed_by
`

type CreateKnowledgeSubmissionParams struct {
	Title       string         `json:"title"`
	Content     string         `json:"content"`
	Category    sql.NullString `json:"category"`
	SubmittedBy int64          `json:"submitted_by"`
}

// ============ KNOWLEDGE SUBMISSIONS ============
func (q *Queries) CreateKnowledgeSubmission(ctx context.Context, arg CreateKnowledgeSubmissionParams) (KnowledgeSubmission, error) {
	row := q.db.QueryRowContext(ctx, createKnowledgeSubmission,
		arg.Title,
		arg.Content,
		arg.Category,
		arg.SubmittedBy,
	)
	var i KnowledgeSubmission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Category,
		&i.SubmittedBy,
		&i.Status,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.ReviewedBy,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one

INSERT INTO notifications (user_id, type, title, message)
VALUES (?, ?, ?, ?)
RETURNING id, user_id, type, title, message, read, created_at
`

type CreateNotificationParams struct {
	UserID  int64  `json:"user_id"`
	Type    string `json:"type"`
	Title   string `json:"title"`
	Message string `json:"message"`
}

// ============ NOTIFICATIONS ============
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, createNotification,
		arg.UserID,
		arg.Type,
		arg.Title,
		arg.Message,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Title,
		&i.Message,
		&i.Read,
		&i.CreatedAt,
	)
	return i, err
}

const createSecurityFilter = `-- name: CreateSecurityFilter :one

INSERT INTO security_filters (name, description, filter_type, pattern, action, applies_to, severity, created_by)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, description, filter_type, pattern, "action", is_active, applies_to, severity, created_by, created_at, updated_at
`

type CreateSecurityFilterParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	FilterType  string         `json:"filter_type"`
	Pattern     string         `json:"pattern"`
	Action      string         `json:"action"`
	AppliesTo   sql.NullString `json:"applies_to"`
	Severity    sql.NullString `json:"severity"`
	CreatedBy   sql.NullInt64  `json:"created_by"`
}

// ============ SECURITY FILTERS ============
func (q *Queries) CreateSecurityFilter(ctx context.Context, arg CreateSecurityFilterParams) (SecurityFilter, error) {
	row := q.db.QueryRowContext(ctx, createSecurityFilter,
		arg.Name,
		arg.Description,
		arg.FilterType,
		arg.Pattern,
		arg.Action,
		arg.AppliesTo,
		arg.Severity,
		arg.CreatedBy,
	)
	var i SecurityFilter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FilterType,
		&i.Pattern,
		&i.Action,
		&i.IsActive,
		&i.AppliesTo,
		&i.Severity,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSecurityLog = `-- name: CreateSecurityLog :one

INSERT INTO security_logs (user_id, filter_id, original_content, action_taken, ip_address, user_agent)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, user_id, filter_id, original_content, action_taken, ip_address, user_agent, created_at
`

type CreateSecurityLogParams struct {
	UserID          int64          `json:"user_id"`
	FilterID        sql.NullInt64  `json:"filter_id"`
	OriginalContent string         `json:"original_content"`
	ActionTaken     string         `json:"action_taken"`
	IpAddress       sql.NullString `json:"ip_address"`
	UserAgent       sql.NullString `json:"user_agent"`
}

// ============ SECURITY LOGS ============
func (q *Queries) CreateSecurityLog(ctx context.Context, arg CreateSecurityLogParams) (SecurityLog, error) {
	row := q.db.QueryRowContext(ctx, createSecurityLog,
		arg.UserID,
		arg.FilterID,
		arg.OriginalContent,
		arg.ActionTaken,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i SecurityLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FilterID,
		&i.OriginalContent,
		&i.ActionTaken,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (user_id, token, expires_at)
VALUES (?, ?, ?)
RETURNING id, user_id, token, expires_at, created_at
`

type CreateSessionParams struct {
	UserID    int64     `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

// ============ SESSIONS ============
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession, arg.UserID, arg.Token, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUnansweredQuestion = `-- name: CreateUnansweredQuestion :one

INSERT INTO unanswered_questions (question, asked_by, conversation_id)
VALUES (?, ?, ?)
RETURNING id, question, asked_by, conversation_id, answer, answered_by, status, add_to_knowledge, created_at, answered_at
`

type CreateUnansweredQuestionParams struct {
	Question       string        `json:"question"`
	AskedBy        int64         `json:"asked_by"`
	ConversationID sql.NullInt64 `json:"conversation_id"`
}

// ============ UNANSWERED QUESTIONS ============
func (q *Queries) CreateUnansweredQuestion(ctx context.Context, arg CreateUnansweredQuestionParams) (UnansweredQuestion, error) {
	row := q.db.QueryRowContext(ctx, createUnansweredQuestion, arg.Question, arg.AskedBy, arg.ConversationID)
	var i UnansweredQuestion
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.AskedBy,
		&i.ConversationID,
		&i.Answer,
		&i.AnsweredBy,
		&i.Status,
		&i.AddToKnowledge,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (nomina, password_hash, nombre, departamento)
VALUES (?, ?, ?, ?)
RETURNING id, nomina, password_hash, nombre, departamento, approved, is_admin, created_at, updated_at
`

type CreateUserParams struct {
	Nomina       string         `json:"nomina"`
	PasswordHash string         `json:"password_hash"`
	Nombre       string         `json:"nombre"`
	Departamento sql.NullString `json:"departamento"`
}

// ============ USERS ============
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Nomina,
		arg.PasswordHash,
		arg.Nombre,
		arg.Departamento,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nomina,
		&i.PasswordHash,
		&i.Nombre,
		&i.Departamento,
		&i.Approved,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConfig = `-- name: DeleteConfig :execresult
DELETE FROM system_config WHERE key = ?
`

func (q *Queries) DeleteConfig(ctx context.Context, key string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteConfig, key)
}

const deleteConversation = `-- name: DeleteConversation :execresult
DELETE FROM ai_conversations WHERE id = ? AND user_id = ?
`

type DeleteConversationParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteConversation(ctx context.Context, arg DeleteConversationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteConversation, arg.ID, arg.UserID)
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execresult
DELETE FROM sessions WHERE expires_at <= datetime('now')
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteExpiredSessions)
}

const deleteFilterCategory = `-- name: DeleteFilterCategory :execresult
DELETE FROM filter_categories WHERE id = ?
`

func (q *Queries) DeleteFilterCategory(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteFilterCategory, id)
}

const deleteKnowledge = `-- name: DeleteKnowledge :execresult
DELETE FROM knowledge_base WHERE id = ?
`

func (q *Queries) DeleteKnowledge(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteKnowledge, id)
}

const deleteOldNotifications = `-- name: DeleteOldNotifications :execresult
DELETE FROM notifications WHERE created_at < datetime('now', '-30 days')
`

func (q *Queries) DeleteOldNotifications(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteOldNotifications)
}

const deleteSecurityFilter = `-- name: DeleteSecurityFilter :execresult
DELETE FROM security_filters WHERE id = ?
`

func (q *Queries) DeleteSecurityFilter(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteSecurityFilter, id)
}

const deleteSession = `-- name: DeleteSession :execresult
DELETE FROM sessions WHERE token = ?
`

func (q *Queries) DeleteSession(ctx context.Context, token string) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteSession, token)
}

const deleteUser = `-- name: DeleteUser :execresult
DELETE FROM users WHERE id = ? AND is_admin = 0
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteUser, id)
}

const deleteUserSessions = `-- name: DeleteUserSessions :execresult
DELETE FROM sessions WHERE user_id = ?
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteUserSessions, userID)
}

const getActiveFilterCategories = `-- name: GetActiveFilterCategories :many
SELECT id, name, description, is_active, created_at FROM filter_categories WHERE is_active = 1 ORDER BY name ASC
`

func (q *Queries) GetActiveFilterCategories(ctx context.Context) ([]FilterCategory, error) {
	rows, err := q.db.QueryContext(ctx, getActiveFilterCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterCategory
	for rows.Next() {
		var i FilterCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveKnowledge = `-- name: GetActiveKnowledge :many
SELECT
    kb.id, kb.title, kb.content, kb.category, kb.submitted_by, kb.approved_by, kb.is_active, kb.created_at, kb.approved_at,
    u1.nombre as submitted_by_name,
    u2.nombre as approved_by_name
FROM knowledge_base kb
JOIN users u1 ON kb.submitted_by = u1.id
LEFT JOIN users u2 ON kb.approved_by = u2.id
WHERE kb.is_active = 1
ORDER BY kb.created_at DESC
`

type GetActiveKnowledgeRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Content         string         `json:"content"`
	Category        sql.NullString `json:"category"`
	SubmittedBy     int64          `json:"submitted_by"`
	ApprovedBy      sql.NullInt64  `json:"approved_by"`
	IsActive        sql.NullInt64  `json:"is_active"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	ApprovedAt      sql.NullTime   `json:"approved_at"`
	SubmittedByName string         `json:"submitted_by_name"`
	ApprovedByName  sql.NullString `json:"approved_by_name"`
}

func (q *Queries) GetActiveKnowledge(ctx context.Context) ([]GetActiveKnowledgeRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveKnowledge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveKnowledgeRow
	for rows.Next() {
		var i GetActiveKnowledgeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.ApprovedBy,
			&i.IsActive,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.SubmittedByName,
			&i.ApprovedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveSecurityFilters = `-- name: GetActiveSecurityFilters :many
SELECT id, name, description, filter_type, pattern, "action", is_active, applies_to, severity, created_by, created_at, updated_at FROM security_filters
WHERE is_active = 1
ORDER BY severity DESC, name ASC
`

func (q *Queries) GetActiveSecurityFilters(ctx context.Context) ([]SecurityFilter, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSecurityFilters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecurityFilter
	for rows.Next() {
		var i SecurityFilter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Pattern,
			&i.Action,
			&i.IsActive,
			&i.AppliesTo,
			&i.Severity,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminUserIDs = `-- name: GetAdminUserIDs :many
SELECT id FROM users WHERE is_admin = 1
`

func (q *Queries) GetAdminUserIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getAdminUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllConfig = `-- name: GetAllConfig :many
SELECT id, "key", value, description, updated_at FROM system_config ORDER BY key ASC
`

func (q *Queries) GetAllConfig(ctx context.Context) ([]SystemConfig, error) {
	rows, err := q.db.QueryContext(ctx, getAllConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SystemConfig
	for rows.Next() {
		var i SystemConfig
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllKnowledge = `-- name: GetAllKnowledge :many
SELECT
    kb.id, kb.title, kb.content, kb.category, kb.submitted_by, kb.approved_by, kb.is_active, kb.created_at, kb.approved_at,
    u1.nombre as submitted_by_name,
    u2.nombre as approved_by_name
FROM knowledge_base kb
JOIN users u1 ON kb.submitted_by = u1.id
LEFT JOIN users u2 ON kb.approved_by = u2.id
ORDER BY kb.created_at DESC
`

type GetAllKnowledgeRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Content         string         `json:"content"`
	Category        sql.NullString `json:"category"`
	SubmittedBy     int64          `json:"submitted_by"`
	ApprovedBy      sql.NullInt64  `json:"approved_by"`
	IsActive        sql.NullInt64  `json:"is_active"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	ApprovedAt      sql.NullTime   `json:"approved_at"`
	SubmittedByName string         `json:"submitted_by_name"`
	ApprovedByName  sql.NullString `json:"approved_by_name"`
}

func (q *Queries) GetAllKnowledge(ctx context.Context) ([]GetAllKnowledgeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllKnowledge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllKnowledgeRow
	for rows.Next() {
		var i GetAllKnowledgeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.ApprovedBy,
			&i.IsActive,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.SubmittedByName,
			&i.ApprovedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllQuestions = `-- name: GetAllQuestions :many
SELECT
    uq.id, uq.question, uq.asked_by, uq.conversation_id, uq.answer, uq.answered_by, uq.status, uq.add_to_knowledge, uq.created_at, uq.answered_at,
    u1.nombre as asked_by_name,
    u2.nombre as answered_by_name
FROM unanswered_questions uq
JOIN users u1 ON uq.asked_by = u1.id
LEFT JOIN users u2 ON uq.answered_by = u2.id
ORDER BY uq.created_at DESC
`

type GetAllQuestionsRow struct {
	ID             int64          `json:"id"`
	Question       string         `json:"question"`
	AskedBy        int64          `json:"asked_by"`
	ConversationID sql.NullInt64  `json:"conversation_id"`
	Answer         sql.NullString `json:"answer"`
	AnsweredBy     sql.NullInt64  `json:"answered_by"`
	Status         sql.NullString `json:"status"`
	AddToKnowledge sql.NullInt64  `json:"add_to_knowledge"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	AnsweredAt     sql.NullTime   `json:"answered_at"`
	AskedByName    string         `json:"asked_by_name"`
	AnsweredByName sql.NullString `json:"answered_by_name"`
}

func (q *Queries) GetAllQuestions(ctx context.Context) ([]GetAllQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllQuestionsRow
	for rows.Next() {
		var i GetAllQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.AskedBy,
			&i.ConversationID,
			&i.Answer,
			&i.AnsweredBy,
			&i.Status,
			&i.AddToKnowledge,
			&i.CreatedAt,
			&i.AnsweredAt,
			&i.AskedByName,
			&i.AnsweredByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSecurityFilters = `-- name: GetAllSecurityFilters :many
SELECT
    sf.id, sf.name, sf.description, sf.filter_type, sf.pattern, sf."action", sf.is_active, sf.applies_to, sf.severity, sf.created_by, sf.created_at, sf.updated_at,
    u.nombre as created_by_name
FROM security_filters sf
LEFT JOIN users u ON sf.created_by = u.id
ORDER BY sf.created_at DESC
`

type GetAllSecurityFiltersRow struct {
	ID            int64          `json:"id"`
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	FilterType    string         `json:"filter_type"`
	Pattern       string         `json:"pattern"`
	Action        string         `json:"action"`
	IsActive      sql.NullInt64  `json:"is_active"`
	AppliesTo     sql.NullString `json:"applies_to"`
	Severity      sql.NullString `json:"severity"`
	CreatedBy     sql.NullInt64  `json:"created_by"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
	CreatedByName sql.NullString `json:"created_by_name"`
}

func (q *Queries) GetAllSecurityFilters(ctx context.Context) ([]GetAllSecurityFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSecurityFilters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSecurityFiltersRow
	for rows.Next() {
		var i GetAllSecurityFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Pattern,
			&i.Action,
			&i.IsActive,
			&i.AppliesTo,
			&i.Severity,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubmissions = `-- name: GetAllSubmissions :many
SELECT
    ks.id, ks.title, ks.content, ks.category, ks.submitted_by, ks.status, ks.admin_notes, ks.created_at, ks.reviewed_at, ks.reviewed_by,
    u1.nombre as submitted_by_name,
    u1.nomina as submitted_by_nomina,
    u2.nombre as reviewed_by_name
FROM knowledge_submissions ks
JOIN users u1 ON ks.submitted_by = u1.id
LEFT JOIN users u2 ON ks.reviewed_by = u2.id
ORDER BY ks.created_at DESC
`

type GetAllSubmissionsRow struct {
	ID                int64          `json:"id"`
	Title             string         `json:"title"`
	Content           string         `json:"content"`
	Category          sql.NullString `json:"category"`
	SubmittedBy       int64          `json:"submitted_by"`
	Status            sql.NullString `json:"status"`
	AdminNotes        sql.NullString `json:"admin_notes"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	ReviewedAt        sql.NullTime   `json:"reviewed_at"`
	ReviewedBy        sql.NullInt64  `json:"reviewed_by"`
	SubmittedByName   string         `json:"submitted_by_name"`
	SubmittedByNomina string         `json:"submitted_by_nomina"`
	ReviewedByName    sql.NullString `json:"reviewed_by_name"`
}

func (q *Queries) GetAllSubmissions(ctx context.Context) ([]GetAllSubmissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubmissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubmissionsRow
	for rows.Next() {
		var i GetAllSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.Status,
			&i.AdminNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.ReviewedBy,
			&i.SubmittedByName,
			&i.SubmittedByNomina,
			&i.ReviewedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, nomina, nombre, departamento, approved, is_admin, created_at
FROM users
ORDER BY created_at DESC
`

type GetAllUsersRow struct {
	ID           int64          `json:"id"`
	Nomina       string         `json:"nomina"`
	Nombre       string         `json:"nombre"`
	Departamento sql.NullString `json:"departamento"`
	Approved     sql.NullInt64  `json:"approved"`
	IsAdmin      sql.NullInt64  `json:"is_admin"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nomina,
			&i.Nombre,
			&i.Departamento,
			&i.Approved,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovedUsers = `-- name: GetApprovedUsers :many
SELECT id, nomina, nombre, departamento, created_at
FROM users
WHERE approved = 1
ORDER BY nombre ASC
`

type GetApprovedUsersRow struct {
	ID           int64          `json:"id"`
	Nomina       string         `json:"nomina"`
	Nombre       string         `json:"nombre"`
	Departamento sql.NullString `json:"departamento"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetApprovedUsers(ctx context.Context) ([]GetApprovedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getApprovedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApprovedUsersRow
	for rows.Next() {
		var i GetApprovedUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nomina,
			&i.Nombre,
			&i.Departamento,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfig = `-- name: GetConfig :one

SELECT value FROM system_config WHERE key = ?
`

// ============ SYSTEM CONFIG ============
func (q *Queries) GetConfig(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRowContext(ctx, getConfig, key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getConversation = `-- name: GetConversation :one
SELECT id, user_id, title, created_at, updated_at FROM ai_conversations
WHERE id = ? AND user_id = ?
`

type GetConversationParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetConversation(ctx context.Context, arg GetConversationParams) (AiConversation, error) {
	row := q.db.QueryRowContext(ctx, getConversation, arg.ID, arg.UserID)
	var i AiConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT id, user_id, title, created_at, updated_at FROM ai_conversations WHERE id = ?
`

func (q *Queries) GetConversationByID(ctx context.Context, id int64) (AiConversation, error) {
	row := q.db.QueryRowContext(ctx, getConversationByID, id)
	var i AiConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT id, role, content, filtered, filter_reason, created_at
FROM ai_messages
WHERE conversation_id = ?
ORDER BY created_at ASC
`

type GetConversationMessagesRow struct {
	ID           int64          `json:"id"`
	Role         string         `json:"role"`
	Content      string         `json:"content"`
	Filtered     sql.NullInt64  `json:"filtered"`
	FilterReason sql.NullString `json:"filter_reason"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetConversationMessages(ctx context.Context, conversationID int64) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversationMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRow
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.Filtered,
			&i.FilterReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardStats = `-- name: GetDashboardStats :one

SELECT
    (SELECT COUNT(*) FROM users WHERE approved = 1) as total_users,
    (SELECT COUNT(*) FROM users WHERE approved = 0 AND is_admin = 0) as pending_users,
    (SELECT COUNT(*) FROM ai_conversations) as total_conversations,
    (SELECT COUNT(*) FROM ai_messages) as total_ai_messages,
    (SELECT COUNT(*) FROM group_messages) as total_group_messages,
    (SELECT COUNT(*) FROM security_logs WHERE date(created_at) = date('now')) as security_incidents_today
`

type GetDashboardStatsRow struct {
	TotalUsers             int64 `json:"total_users"`
	PendingUsers           int64 `json:"pending_users"`
	TotalConversations     int64 `json:"total_conversations"`
	TotalAiMessages        int64 `json:"total_ai_messages"`
	TotalGroupMessages     int64 `json:"total_group_messages"`
	SecurityIncidentsToday int64 `json:"security_incidents_today"`
}

// ============ STATISTICS ============
func (q *Queries) GetDashboardStats(ctx context.Context) (GetDashboardStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardStats)
	var i GetDashboardStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.PendingUsers,
		&i.TotalConversations,
		&i.TotalAiMessages,
		&i.TotalGroupMessages,
		&i.SecurityIncidentsToday,
	)
	return i, err
}

const getFilterCategories = `-- name: GetFilterCategories :many

SELECT id, name, description, is_active, created_at FROM filter_categories ORDER BY name ASC
`

// ============ FILTER CATEGORIES ============
func (q *Queries) GetFilterCategories(ctx context.Context) ([]FilterCategory, error) {
	rows, err := q.db.QueryContext(ctx, getFilterCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterCategory
	for rows.Next() {
		var i FilterCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredMessages = `-- name: GetFilteredMessages :many
SELECT
    m.id, m.role, m.content, m.filter_reason, m.created_at,
    c.user_id, u.nombre, u.nomina
FROM ai_messages m
JOIN ai_conversations c ON m.conversation_id = c.id
JOIN users u ON c.user_id = u.id
WHERE m.filtered = 1
ORDER BY m.created_at DESC
LIMIT ?
`

type GetFilteredMessagesRow struct {
	ID           int64          `json:"id"`
	Role         string         `json:"role"`
	Content      string         `json:"content"`
	FilterReason sql.NullString `json:"filter_reason"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UserID       int64          `json:"user_id"`
	Nombre       string         `json:"nombre"`
	Nomina       string         `json:"nomina"`
}

func (q *Queries) GetFilteredMessages(ctx context.Context, limit int64) ([]GetFilteredMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredMessagesRow
	for rows.Next() {
		var i GetFilteredMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.FilterReason,
			&i.CreatedAt,
			&i.UserID,
			&i.Nombre,
			&i.Nomina,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMessagesSince = `-- name: GetGroupMessagesSince :many
SELECT
    gm.id, gm.content, gm.created_at,
    u.id as user_id, u.nombre, u.nomina
FROM group_messages gm
JOIN users u ON gm.user_id = u.id
WHERE gm.id > ?
ORDER BY gm.created_at ASC
`

type GetGroupMessagesSinceRow struct {
	ID        int64        `json:"id"`
	Content   string       `json:"content"`
	CreatedAt sql.NullTime `json:"created_at"`
	UserID    int64        `json:"user_id"`
	Nombre    string       `json:"nombre"`
	Nomina    string       `json:"nomina"`
}

func (q *Queries) GetGroupMessagesSince(ctx context.Context, id int64) ([]GetGroupMessagesSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupMessagesSince, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMessagesSinceRow
	for rows.Next() {
		var i GetGroupMessagesSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.CreatedAt,
			&i.UserID,
			&i.Nombre,
			&i.Nomina,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKnowledgeByCategory = `-- name: GetKnowledgeByCategory :many
SELECT
    kb.id, kb.title, kb.content, kb.category, kb.submitted_by, kb.approved_by, kb.is_active, kb.created_at, kb.approved_at,
    u1.nombre as submitted_by_name
FROM knowledge_base kb
JOIN users u1 ON kb.submitted_by = u1.id
WHERE kb.is_active = 1 AND kb.category = ?
ORDER BY kb.created_at DESC
`

type GetKnowledgeByCategoryRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Content         string         `json:"content"`
	Category        sql.NullString `json:"category"`
	SubmittedBy     int64          `json:"submitted_by"`
	ApprovedBy      sql.NullInt64  `json:"approved_by"`
	IsActive        sql.NullInt64  `json:"is_active"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	ApprovedAt      sql.NullTime   `json:"approved_at"`
	SubmittedByName string         `json:"submitted_by_name"`
}

func (q *Queries) GetKnowledgeByCategory(ctx context.Context, category sql.NullString) ([]GetKnowledgeByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getKnowledgeByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKnowledgeByCategoryRow
	for rows.Next() {
		var i GetKnowledgeByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.ApprovedBy,
			&i.IsActive,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.SubmittedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKnowledgeByID = `-- name: GetKnowledgeByID :one
SELECT id, title, content, category, submitted_by, approved_by, is_active, created_at, approved_at FROM knowledge_base WHERE id = ?
`

func (q *Queries) GetKnowledgeByID(ctx context.Context, id int64) (KnowledgeBase, error) {
	row := q.db.QueryRowContext(ctx, getKnowledgeByID, id)
	var i KnowledgeBase
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Category,
		&i.SubmittedBy,
		&i.ApprovedBy,
		&i.IsActive,
		&i.CreatedAt,
		&i.ApprovedAt,
	)
	return i, err
}

const getKnowledgeContext = `-- name: GetKnowledgeContext :many
SELECT title, content, category FROM knowledge_base
WHERE is_active = 1
ORDER BY category, created_at DESC
`

type GetKnowledgeContextRow struct {
	Title    string         `json:"title"`
	Content  string         `json:"content"`
	Category sql.NullString `json:"category"`
}

func (q *Queries) GetKnowledgeContext(ctx context.Context) ([]GetKnowledgeContextRow, error) {
	rows, err := q.db.QueryContext(ctx, getKnowledgeContext)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKnowledgeContextRow
	for rows.Next() {
		var i GetKnowledgeContextRow
		if err := rows.Scan(&i.Title, &i.Content, &i.Category); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingQuestions = `-- name: GetPendingQuestions :many
SELECT
    uq.id, uq.question, uq.asked_by, uq.conversation_id, uq.answer, uq.answered_by, uq.status, uq.add_to_knowledge, uq.created_at, uq.answered_at,
    u.nombre as asked_by_name,
    u.nomina as asked_by_nomina
FROM unanswered_questions uq
JOIN users u ON uq.asked_by = u.id
WHERE uq.status = 'pending'
ORDER BY uq.created_at DESC
`

type GetPendingQuestionsRow struct {
	ID             int64          `json:"id"`
	Question       string         `json:"question"`
	AskedBy        int64          `json:"asked_by"`
	ConversationID sql.NullInt64  `json:"conversation_id"`
	Answer         sql.NullString `json:"answer"`
	AnsweredBy     sql.NullInt64  `json:"answered_by"`
	Status         sql.NullString `json:"status"`
	AddToKnowledge sql.NullInt64  `json:"add_to_knowledge"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	AnsweredAt     sql.NullTime   `json:"answered_at"`
	AskedByName    string         `json:"asked_by_name"`
	AskedByNomina  string         `json:"asked_by_nomina"`
}

func (q *Queries) GetPendingQuestions(ctx context.Context) ([]GetPendingQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingQuestionsRow
	for rows.Next() {
		var i GetPendingQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.AskedBy,
			&i.ConversationID,
			&i.Answer,
			&i.AnsweredBy,
			&i.Status,
			&i.AddToKnowledge,
			&i.CreatedAt,
			&i.AnsweredAt,
			&i.AskedByName,
			&i.AskedByNomina,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSubmissions = `-- name: GetPendingSubmissions :many
SELECT
    ks.id, ks.title, ks.content, ks.category, ks.submitted_by, ks.status, ks.admin_notes, ks.created_at, ks.reviewed_at, ks.reviewed_by,
    u.nombre as submitted_by_name,
    u.nomina as submitted_by_nomina
FROM knowledge_submissions ks
JOIN users u ON ks.submitted_by = u.id
WHERE ks.status = 'pending'
ORDER BY ks.created_at DESC
`

type GetPendingSubmissionsRow struct {
	ID                int64          `json:"id"`
	Title             string         `json:"title"`
	Content           string         `json:"content"`
	Category          sql.NullString `json:"category"`
	SubmittedBy       int64          `json:"submitted_by"`
	Status            sql.NullString `json:"status"`
	AdminNotes        sql.NullString `json:"admin_notes"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	ReviewedAt        sql.NullTime   `json:"reviewed_at"`
	ReviewedBy        sql.NullInt64  `json:"reviewed_by"`
	SubmittedByName   string         `json:"submitted_by_name"`
	SubmittedByNomina string         `json:"submitted_by_nomina"`
}

func (q *Queries) GetPendingSubmissions(ctx context.Context) ([]GetPendingSubmissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSubmissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSubmissionsRow
	for rows.Next() {
		var i GetPendingSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.Status,
			&i.AdminNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.ReviewedBy,
			&i.SubmittedByName,
			&i.SubmittedByNomina,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingUsers = `-- name: GetPendingUsers :many
SELECT id, nomina, nombre, departamento, created_at
FROM users
WHERE approved = 0 AND is_admin = 0
ORDER BY created_at DESC
`

type GetPendingUsersRow struct {
	ID           int64          `json:"id"`
	Nomina       string         `json:"nomina"`
	Nombre       string         `json:"nombre"`
	Departamento sql.NullString `json:"departamento"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetPendingUsers(ctx context.Context) ([]GetPendingUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingUsersRow
	for rows.Next() {
		var i GetPendingUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Nomina,
			&i.Nombre,
			&i.Departamento,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, question, asked_by, conversation_id, answer, answered_by, status, add_to_knowledge, created_at, answered_at FROM unanswered_questions WHERE id = ?
`

func (q *Queries) GetQuestionByID(ctx context.Context, id int64) (UnansweredQuestion, error) {
	row := q.db.QueryRowContext(ctx, getQuestionByID, id)
	var i UnansweredQuestion
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.AskedBy,
		&i.ConversationID,
		&i.Answer,
		&i.AnsweredBy,
		&i.Status,
		&i.AddToKnowledge,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const getRecentConversationMessages = `-- name: GetRecentConversationMessages :many
SELECT id, role, content, filtered, filter_reason, created_at
FROM ai_messages
WHERE conversation_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetRecentConversationMessagesParams struct {
	ConversationID int64 `json:"conversation_id"`
	Limit          int64 `json:"limit"`
}

type GetRecentConversationMessagesRow struct {
	ID           int64          `json:"id"`
	Role         string         `json:"role"`
	Content      string         `json:"content"`
	Filtered     sql.NullInt64  `json:"filtered"`
	FilterReason sql.NullString `json:"filter_reason"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetRecentConversationMessages(ctx context.Context, arg GetRecentConversationMessagesParams) ([]GetRecentConversationMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentConversationMessages, arg.ConversationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentConversationMessagesRow
	for rows.Next() {
		var i GetRecentConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.Filtered,
			&i.FilterReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentGroupMessages = `-- name: GetRecentGroupMessages :many
SELECT
    gm.id, gm.content, gm.created_at,
    u.id as user_id, u.nombre, u.nomina
FROM group_messages gm
JOIN users u ON gm.user_id = u.id
ORDER BY gm.created_at DESC
LIMIT ?
`

type GetRecentGroupMessagesRow struct {
	ID        int64        `json:"id"`
	Content   string       `json:"content"`
	CreatedAt sql.NullTime `json:"created_at"`
	UserID    int64        `json:"user_id"`
	Nombre    string       `json:"nombre"`
	Nomina    string       `json:"nomina"`
}

func (q *Queries) GetRecentGroupMessages(ctx context.Context, limit int64) ([]GetRecentGroupMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentGroupMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentGroupMessagesRow
	for rows.Next() {
		var i GetRecentGroupMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.CreatedAt,
			&i.UserID,
			&i.Nombre,
			&i.Nomina,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSecurityLogs = `-- name: GetRecentSecurityLogs :many
SELECT
    sl.id, sl.user_id, sl.filter_id, sl.original_content, sl.action_taken, sl.ip_address, sl.user_agent, sl.created_at,
    u.nombre, u.nomina,
    sf.name as filter_name, sf.severity
FROM security_logs sl
JOIN users u ON sl.user_id = u.id
LEFT JOIN security_filters sf ON sl.filter_id = sf.id
ORDER BY sl.created_at DESC
LIMIT ?
`

type GetRecentSecurityLogsRow struct {
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
	FilterID        sql.NullInt64  `json:"filter_id"`
	OriginalContent string         `json:"original_content"`
	ActionTaken     string         `json:"action_taken"`
	IpAddress       sql.NullString `json:"ip_address"`
	UserAgent       sql.NullString `json:"user_agent"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	Nombre          string         `json:"nombre"`
	Nomina          string         `json:"nomina"`
	FilterName      sql.NullString `json:"filter_name"`
	Severity        sql.NullString `json:"severity"`
}

func (q *Queries) GetRecentSecurityLogs(ctx context.Context, limit int64) ([]GetRecentSecurityLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentSecurityLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSecurityLogsRow
	for rows.Next() {
		var i GetRecentSecurityLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FilterID,
			&i.OriginalContent,
			&i.ActionTaken,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Nombre,
			&i.Nomina,
			&i.FilterName,
			&i.Severity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityFilterByID = `-- name: GetSecurityFilterByID :one
SELECT id, name, description, filter_type, pattern, "action", is_active, applies_to, severity, created_by, created_at, updated_at FROM security_filters WHERE id = ?
`

func (q *Queries) GetSecurityFilterByID(ctx context.Context, id int64) (SecurityFilter, error) {
	row := q.db.QueryRowContext(ctx, getSecurityFilterByID, id)
	var i SecurityFilter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.FilterType,
		&i.Pattern,
		&i.Action,
		&i.IsActive,
		&i.AppliesTo,
		&i.Severity,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSecurityFiltersByAppliesTo = `-- name: GetSecurityFiltersByAppliesTo :many
SELECT id, name, description, filter_type, pattern, "action", is_active, applies_to, severity, created_by, created_at, updated_at FROM security_filters
WHERE (applies_to = ? OR applies_to = 'both') AND is_active = 1
ORDER BY severity DESC
`

func (q *Queries) GetSecurityFiltersByAppliesTo(ctx context.Context, appliesTo sql.NullString) ([]SecurityFilter, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityFiltersByAppliesTo, appliesTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecurityFilter
	for rows.Next() {
		var i SecurityFilter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Pattern,
			&i.Action,
			&i.IsActive,
			&i.AppliesTo,
			&i.Severity,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityFiltersByType = `-- name: GetSecurityFiltersByType :many
SELECT id, name, description, filter_type, pattern, "action", is_active, applies_to, severity, created_by, created_at, updated_at FROM security_filters
WHERE filter_type = ? AND is_active = 1
ORDER BY severity DESC
`

func (q *Queries) GetSecurityFiltersByType(ctx context.Context, filterType string) ([]SecurityFilter, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityFiltersByType, filterType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecurityFilter
	for rows.Next() {
		var i SecurityFilter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Pattern,
			&i.Action,
			&i.IsActive,
			&i.AppliesTo,
			&i.Severity,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityLogsByDateRange = `-- name: GetSecurityLogsByDateRange :many
SELECT
    sl.id, sl.user_id, sl.filter_id, sl.original_content, sl.action_taken, sl.ip_address, sl.user_agent, sl.created_at,
    u.nombre, u.nomina,
    sf.name as filter_name, sf.severity
FROM security_logs sl
JOIN users u ON sl.user_id = u.id
LEFT JOIN security_filters sf ON sl.filter_id = sf.id
WHERE sl.created_at BETWEEN ? AND ?
ORDER BY sl.created_at DESC
`

type GetSecurityLogsByDateRangeParams struct {
	FromCreatedAt   sql.NullTime `json:"from_created_at"`
	FromCreatedAt_2 sql.NullTime `json:"from_created_at_2"`
	FromCreatedAt_3 sql.NullTime `json:"from_created_at_3"`
	ToCreatedAt     sql.NullTime `json:"to_created_at"`
	ToCreatedAt_2   sql.NullTime `json:"to_created_at_2"`
	ToCreatedAt_3   sql.NullTime `json:"to_created_at_3"`
}

type GetSecurityLogsByDateRangeRow struct {
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
	FilterID        sql.NullInt64  `json:"filter_id"`
	OriginalContent string         `json:"original_content"`
	ActionTaken     string         `json:"action_taken"`
	IpAddress       sql.NullString `json:"ip_address"`
	UserAgent       sql.NullString `json:"user_agent"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	Nombre          string         `json:"nombre"`
	Nomina          string         `json:"nomina"`
	FilterName      sql.NullString `json:"filter_name"`
	Severity        sql.NullString `json:"severity"`
}

func (q *Queries) GetSecurityLogsByDateRange(ctx context.Context, arg GetSecurityLogsByDateRangeParams) ([]GetSecurityLogsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityLogsByDateRange,
		arg.FromCreatedAt,
		arg.FromCreatedAt_2,
		arg.FromCreatedAt_3,
		arg.ToCreatedAt,
		arg.ToCreatedAt_2,
		arg.ToCreatedAt_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecurityLogsByDateRangeRow
	for rows.Next() {
		var i GetSecurityLogsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FilterID,
			&i.OriginalContent,
			&i.ActionTaken,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Nombre,
			&i.Nomina,
			&i.FilterName,
			&i.Severity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityLogsByUser = `-- name: GetSecurityLogsByUser :many
SELECT
    sl.id, sl.user_id, sl.filter_id, sl.original_content, sl.action_taken, sl.ip_address, sl.user_agent, sl.created_at,
    sf.name as filter_name, sf.severity
FROM security_logs sl
LEFT JOIN security_filters sf ON sl.filter_id = sf.id
WHERE sl.user_id = ?
ORDER BY sl.created_at DESC
LIMIT ?
`

type GetSecurityLogsByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type GetSecurityLogsByUserRow struct {
	ID              int64          `json:"id"`
	UserID          int64          `json:"user_id"`
	FilterID        sql.NullInt64  `json:"filter_id"`
	OriginalContent string         `json:"original_content"`
	ActionTaken     string         `json:"action_taken"`
	IpAddress       sql.NullString `json:"ip_address"`
	UserAgent       sql.NullString `json:"user_agent"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	FilterName      sql.NullString `json:"filter_name"`
	Severity        sql.NullString `json:"severity"`
}

func (q *Queries) GetSecurityLogsByUser(ctx context.Context, arg GetSecurityLogsByUserParams) ([]GetSecurityLogsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityLogsByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecurityLogsByUserRow
	for rows.Next() {
		var i GetSecurityLogsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FilterID,
			&i.OriginalContent,
			&i.ActionTaken,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FilterName,
			&i.Severity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityStats = `-- name: GetSecurityStats :one
SELECT
    COUNT(*) as total_violations,
    COUNT(DISTINCT user_id) as unique_users,
    (SELECT COUNT(*) FROM security_logs WHERE date(created_at) = date('now')) as today_violations
FROM security_logs
`

type GetSecurityStatsRow struct {
	TotalViolations int64 `json:"total_violations"`
	UniqueUsers     int64 `json:"unique_users"`
	TodayViolations int64 `json:"today_violations"`
}

func (q *Queries) GetSecurityStats(ctx context.Context) (GetSecurityStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSecurityStats)
	var i GetSecurityStatsRow
	err := row.Scan(&i.TotalViolations, &i.UniqueUsers, &i.TodayViolations)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT
    s.id, s.user_id, s.token, s.expires_at,
    u.nomina, u.nombre, u.is_admin, u.approved, u.departamento
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.token = ? AND s.expires_at > datetime('now')
`

type GetSessionByTokenRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Token        string         `json:"token"`
	ExpiresAt    time.Time      `json:"expires_at"`
	Nomina       string         `json:"nomina"`
	Nombre       string         `json:"nombre"`
	IsAdmin      sql.NullInt64  `json:"is_admin"`
	Approved     sql.NullInt64  `json:"approved"`
	Departamento sql.NullString `json:"departamento"`
}

func (q *Queries) GetSessionByToken(ctx context.Context, token string) (GetSessionByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getSessionByToken, token)
	var i GetSessionByTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Nomina,
		&i.Nombre,
		&i.IsAdmin,
		&i.Approved,
		&i.Departamento,
	)
	return i, err
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT
    ks.id, ks.title, ks.content, ks.category, ks.submitted_by, ks.status, ks.admin_notes, ks.created_at, ks.reviewed_at, ks.reviewed_by,
    u.nombre as submitted_by_name
FROM knowledge_submissions ks
JOIN users u ON ks.submitted_by = u.id
WHERE ks.id = ?
`

type GetSubmissionByIDRow struct {
	ID              int64          `json:"id"`
	Title           string         `json:"title"`
	Content         string         `json:"content"`
	Category        sql.NullString `json:"category"`
	SubmittedBy     int64          `json:"submitted_by"`
	Status          sql.NullString `json:"status"`
	AdminNotes      sql.NullString `json:"admin_notes"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	ReviewedAt      sql.NullTime   `json:"reviewed_at"`
	ReviewedBy      sql.NullInt64  `json:"reviewed_by"`
	SubmittedByName string         `json:"submitted_by_name"`
}

func (q *Queries) GetSubmissionByID(ctx context.Context, id int64) (GetSubmissionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSubmissionByID, id)
	var i GetSubmissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Category,
		&i.SubmittedBy,
		&i.Status,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.ReviewedBy,
		&i.SubmittedByName,
	)
	return i, err
}

const getSubmissionsByUser = `-- name: GetSubmissionsByUser :many
SELECT id, title, content, category, submitted_by, status, admin_notes, created_at, reviewed_at, reviewed_by FROM knowledge_submissions
WHERE submitted_by = ?
ORDER BY created_at DESC
`

func (q *Queries) GetSubmissionsByUser(ctx context.Context, submittedBy int64) ([]KnowledgeSubmission, error) {
	rows, err := q.db.QueryContext(ctx, getSubmissionsByUser, submittedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []KnowledgeSubmission
	for rows.Next() {
		var i KnowledgeSubmission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Category,
			&i.SubmittedBy,
			&i.Status,
			&i.AdminNotes,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.ReviewedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadNotifications = `-- name: GetUnreadNotifications :many
SELECT id, user_id, type, title, message, read, created_at FROM notifications
WHERE user_id = ? AND read = 0
ORDER BY created_at DESC
`

func (q *Queries) GetUnreadNotifications(ctx context.Context, userID int64) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Read,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, nomina, password_hash, nombre, departamento, approved, is_admin, created_at, updated_at FROM users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nomina,
		&i.PasswordHash,
		&i.Nombre,
		&i.Departamento,
		&i.Approved,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByNomina = `-- name: GetUserByNomina :one
SELECT id, nomina, password_hash, nombre, departamento, approved, is_admin, created_at, updated_at FROM users WHERE nomina = ?
`

func (q *Queries) GetUserByNomina(ctx context.Context, nomina string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByNomina, nomina)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nomina,
		&i.PasswordHash,
		&i.Nombre,
		&i.Departamento,
		&i.Approved,
		&i.IsAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT id, title, created_at, updated_at
FROM ai_conversations
WHERE user_id = ?
ORDER BY updated_at DESC
LIMIT 50
`

type GetUserConversationsRow struct {
	ID        int64          `json:"id"`
	Title     sql.NullString `json:"title"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetUserConversations(ctx context.Context, userID int64) ([]GetUserConversationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserConversations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserConversationsRow
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, user_id, type, title, message, read, created_at FROM notifications
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetUserNotificationsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUserNotifications, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Title,
			&i.Message,
			&i.Read,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ignoreQuestion = `-- name: IgnoreQuestion :execresult
UPDATE unanswered_questions
SET status = 'ignored', answered_by = ?, answered_at = datetime('now')
WHERE id = ? AND status = 'pending'
`

type IgnoreQuestionParams struct {
	AnsweredBy sql.NullInt64 `json:"answered_by"`
	ID         int64         `json:"id"`
}

func (q *Queries) IgnoreQuestion(ctx context.Context, arg IgnoreQuestionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, ignoreQuestion, arg.AnsweredBy, arg.ID)
}

const markAllNotificationsRead = `-- name: MarkAllNotificationsRead :execresult
UPDATE notifications SET read = 1 WHERE user_id = ? AND read = 0
`

func (q *Queries) MarkAllNotificationsRead(ctx context.Context, userID int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, markAllNotificationsRead, userID)
}

const markNotificationRead = `-- name: MarkNotificationRead :execresult
UPDATE notifications SET read = 1 WHERE id = ? AND user_id = ?
`

type MarkNotificationReadParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, markNotificationRead, arg.ID, arg.UserID)
}

const rejectSubmission = `-- name: RejectSubmission :execresult
UPDATE knowledge_submissions
SET status = 'rejected', reviewed_at = datetime('now'), reviewed_by = ?, admin_notes = ?
WHERE id = ? AND status = 'pending'
`

type RejectSubmissionParams struct {
	ReviewedBy sql.NullInt64  `json:"reviewed_by"`
	AdminNotes sql.NullString `json:"admin_notes"`
	ID         int64          `json:"id"`
}

func (q *Queries) RejectSubmission(ctx context.Context, arg RejectSubmissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, rejectSubmission, arg.ReviewedBy, arg.AdminNotes, arg.ID)
}

const rejectUser = `-- name: RejectUser :execresult
DELETE FROM users WHERE id = ? AND approved = 0 AND is_admin = 0
`

func (q *Queries) RejectUser(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, rejectUser, id)
}

const setConfig = `-- name: SetConfig :execresult
INSERT INTO system_config (key, value, description)
VALUES (?, ?, ?)
ON CONFLICT(key) DO UPDATE SET value = excluded.value, updated_at = datetime('now')
`

type SetConfigParams struct {
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) SetConfig(ctx context.Context, arg SetConfigParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, setConfig, arg.Key, arg.Value, arg.Description)
}

const toggleSecurityFilter = `-- name: ToggleSecurityFilter :execresult
UPDATE security_filters
SET is_active = ?, updated_at = datetime('now')
WHERE id = ?
`

type ToggleSecurityFilterParams struct {
	IsActive sql.NullInt64 `json:"is_active"`
	ID       int64         `json:"id"`
}

func (q *Queries) ToggleSecurityFilter(ctx context.Context, arg ToggleSecurityFilterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, toggleSecurityFilter, arg.IsActive, arg.ID)
}

const touchConversation = `-- name: TouchConversation :execresult
UPDATE ai_conversations
SET updated_at = datetime('now')
WHERE id = ?
`

func (q *Queries) TouchConversation(ctx context.Context, id int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, touchConversation, id)
}

const updateConversationTitle = `-- name: UpdateConversationTitle :execresult
UPDATE ai_conversations
SET title = ?, updated_at = datetime('now')
WHERE id = ? AND user_id = ?
`

type UpdateConversationTitleParams struct {
	Title  sql.NullString `json:"title"`
	ID     int64          `json:"id"`
	UserID int64          `json:"user_id"`
}

func (q *Queries) UpdateConversationTitle(ctx context.Context, arg UpdateConversationTitleParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateConversationTitle, arg.Title, arg.ID, arg.UserID)
}

const updateFilterCategory = `-- name: UpdateFilterCategory :execresult
UPDATE filter_categories SET description = ?, is_active = ? WHERE id = ?
`

type UpdateFilterCategoryParams struct {
	Description sql.NullString `json:"description"`
	IsActive    sql.NullInt64  `json:"is_active"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateFilterCategory(ctx context.Context, arg UpdateFilterCategoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateFilterCategory, arg.Description, arg.IsActive, arg.ID)
}

const updateKnowledge = `-- name: UpdateKnowledge :execresult
UPDATE knowledge_base
SET title = ?, content = ?, category = ?, is_active = ?
WHERE id = ?
`

type UpdateKnowledgeParams struct {
	Title    string         `json:"title"`
	Content  string         `json:"content"`
	Category sql.NullString `json:"category"`
	IsActive sql.NullInt64  `json:"is_active"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateKnowledge(ctx context.Context, arg UpdateKnowledgeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateKnowledge,
		arg.Title,
		arg.Content,
		arg.Category,
		arg.IsActive,
		arg.ID,
	)
}

const updateSecurityFilter = `-- name: UpdateSecurityFilter :execresult
UPDATE security_filters
SET name = ?, description = ?, pattern = ?, action = ?, applies_to = ?, severity = ?, is_active = ?, updated_at = datetime('now')
WHERE id = ?
`

type UpdateSecurityFilterParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Pattern     string         `json:"pattern"`
	Action      string         `json:"action"`
	AppliesTo   sql.NullString `json:"applies_to"`
	Severity    sql.NullString `json:"severity"`
	IsActive    sql.NullInt64  `json:"is_active"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateSecurityFilter(ctx context.Context, arg UpdateSecurityFilterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateSecurityFilter,
		arg.Name,
		arg.Description,
		arg.Pattern,
		arg.Action,
		arg.AppliesTo,
		arg.Severity,
		arg.IsActive,
		arg.ID,
	)
}

const updateUserDepartamento = `-- name: UpdateUserDepartamento :execresult
UPDATE users SET departamento = ?, updated_at = datetime('now') WHERE id = ?
`

type UpdateUserDepartamentoParams struct {
	Departamento sql.NullString `json:"departamento"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateUserDepartamento(ctx context.Context, arg UpdateUserDepartamentoParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserDepartamento, arg.Departamento, arg.ID)
}

const updateUserPassword = `-- name: UpdateUserPassword :execresult

UPDATE users SET password_hash = ?, updated_at = datetime('now')
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int64  `json:"id"`
}

// ============ PASSWORD CHANGE ============
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
}
